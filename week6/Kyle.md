
# 42. Trapping Rain Water

## Solution
```python
class Solution:
    def trap(self, height):
        """
        :type height: List[int]
        :rtype: int
        """
        left, right = 0, len(height) - 1
        ans = 0
        left_max, right_max = 0, 0
        while left < right:
            if height[left] < height[right]:
                left_max = max(left_max, height[left])
                ans += left_max - height[left]
                left += 1
            else:
                right_max = max(right_max, height[right])
                ans += right_max - height[right]
                right -= 1
        return ans
```

## Key Takeway
이 문제는 brute force부터 정확히 짚어내야 최적화 답변도 이해할 수 있다.

특정 위치 i를 기준으로 그 왼쪽에서 가장 큰 것과 그 오른쪽에서 가장 큰 것 둘 중
가장 작은 높이에서 위치i의 높이를 빼는 것이 그 위치에서의 물의 양이 된다. 이걸 모르고 고안해내기란 은근히 어렵다.

brute force는 당연히 시간복잡도가 O(N^2)가 나오므로, 메모이제이션 해법을 찾아야 한다.

brute force에서는 i위치가 바뀔때마다 계속 왼쪽 맥스와 오른쪽 맥스를 다시 계산하므로 반복이 발생한다. 따라서 이를 방지하는 방식으로
메모이제이션을 적용하면 될 것이다. 이를 위해 왼쪽 맥스값과 오른쪽 맥스값을 저장할 배열을 두 개 관리한다.

여기서 매 인덱스 i에 이전까지의 맥스값을 저장하는 방식에 주목하면 좋다.

이러면 for loop이 세 번 도는게 전부이므로 시간복잡도를 O(N)으로 낮출 수 있다.

이걸 원패스로 하려면 투포인터 기법을 쓰면 된다. 이러면 배열을 여러개 안 만들어도 되므로 공간복잡도도 O(1)으로 줄일 수 있다.
논리자체는 간단한데 이걸 노베이스로 생각하려면 쉽지 않다. 

왼쪽 포인터는 0에, 오른쪽 포인터는 마지막 위치에 두고,
while문을 돌리면서 왼쪽포인터 높이와 오른쪽 포인터 높이를 비교해서 왼쪽이 더 낮으면 그리고 왼쪽 max값보다 왼쪽 높이가 더 높으면 왼쪽 max를 업데이트하고, 
왼쪽 max값이 더 크면 업데이트를 따로 안 한다. 그리고선 정답에 왼쪽 max값에서 왼쪽 포인터의 높이를 뺀 값을 더한다. 
그리고 왼쪽 포인터를 한 칸 움직인다.
반대로 오른쪽 포인터에 대해서도 같은 작업을 해준다.

이게 생각하기 쉽지 않은데, 일단 포인터를 양 끝에 두고 하나씩 좁혀온다는 생각은 어렵지 않다.
그 다음 왼쪽 max값보다 왼쪽 포인터위치의 높이가 더 크지 않다면 왼쪽 max값을 그대로 둬야한다. 크다면 높이가 더 높아지는 거니 물이 고여있을리 없고
낮다면 내려가는 것이니 그만큼 물이 고인다고 가정한다. 그 다음 답변을 왼쪽 max에서 왼쪽 포인터위치의 높이를 뺀 값만큼 더해준다.
이러면 물이 고여있으면 양수가 더해지게 된다.

여기서 "어떻게 왼쪽에서 오른쪽으로 진행하면서 높이가 낮아지면 그게 반드시 물이 차는 거냐"고 의문을 제기할 수 있는데,
맨 처음에 왼쪽 포인터 위치의 높이와 오른쪽 포인터 위치의 높이를 비교해서 오른쪽 포인터의 높이가 더 클 때만 이걸 진행하므로,
이 문제가 해결된다. 이게 직관적으로 와닿지 않을 수 있는데, 그림을 그려보면, 전체 배열에 대해 단 한순간이라도 오른쪽 포인터 위치가
왼쪽 포인터보다 높은 경우가 생긴다면 그 왼쪽 포인터에서 아래로 내려갈때는 반드시 물이 가득  차게 된다.

0 2 0 1  이러면 왼쪽이 더 높으니 오른쪽 포인터의 높이값이 항상 낮아 2 -> 0으로 갈 때 물이 찬다고 할 수 없다.
0 2 0 3 이러면 오른쪽 포인터 높이값이 언제나 왼쪽 포인터의 높이값보다 높으니 2 -> 0 으로 갈 때 물이 반드시 찬다.

이 사실을 빨리 캐치해야 최적 해법을 투포인터로 찾을 수 있다.


# 13. Roman to Integer

## Solution
```python


```

## Key Takeway


# 12. Integer to Roman

## Solution
```python

```

## Key Takeway

